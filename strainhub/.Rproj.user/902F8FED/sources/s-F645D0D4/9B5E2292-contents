# File: parsimonymap.R
# Date: 4/22/19
# Author: Adriano Schneider
# Purpose: Plot parsimony based transmission network and map.

library(shiny)
library(ape)
library(castor)
library(visNetwork)
library(hashmap)
library(plyr)
library(dplyr)
library(network)
library(igraph)
library(data.table)
library(magrittr)

#Set working directory

ui <- c("3") #SHR

wd <- ("/Users/schneider/GitHub/MapHubs/demo_data/")

fileName <- c("chikv_westernafrica.nwk.phy")

setwd(wd)

nexusTree2 <- read.tree(fileName) #imports file in newick format instead of nexus.

dataoriginal = read.csv("chikv_westernafrica_metadata.csv", header = TRUE) #imports csv metadata file. It has to have header and ID column has to be the first and labeled "Acession" in order for script to work. 

sortingtable <- as.data.frame(nexusTree2$tip.label) # Takes Tip Label information from Newick tree and transforms into a table, add ID to it and basically reorders the CSV metadata frame to match the Newick file. 
sortingtable <- tibble::rowid_to_column(sortingtable, "ID")
names(sortingtable)[2] <- "Accession"
sortingdata <- merge(dataoriginal, sortingtable, by = "Accession")
data <- sortingdata[order(sortingdata$ID),]

listofcolumns <- as.list(data)
accessioncharacter <- as.character(listofcolumns$Accession) #transforms acession from Factor into character
country <- as.numeric(listofcolumns$Country) #transforms metadata state country from Factor into numeric
names(country) <- accessioncharacter #assign acession ID reference to the variable country

characterlabels1 <- unique(listofcolumns$Country) #extract unique labels from Country column
characterlabels <- sort(as.character(characterlabels1)) #sort and create list of characters from previous vector - has to sort to match the order from the $country as when it becomes numeric is transformed to numbers in alphabetical order.

####################################### END OF NEW BLOCK ###########################################


#charIndex <- readline(prompt ="Type the number equivalent to the character state index of the nexus file you want to build the network from: ")
#characterIndex <- as.numeric(charIndex) #Transforms the input from string to numeric so it can be loaded on metadataRef
rootedTree <- nexusTree2

#\
#  rootedTree structure:
#    list of 3 components:
#      $edge - a numeric matrix with 2 columns. It is the table of edges that describes
#        the phylogenetic tree that was read in by the read.tree() function;
#      $Nnode - a numeric vector of length one whose value is the number of nodes on the 
#        inner branches of the tree;
#      $tip.label - a character vector whose elements are the character string that
#        identifies a leaf node on the phylogenetic tree;
#/


#metadataRef <- nexusData$charMatrix[,characterIndex] #CharacterIndex change the number of the character state index of the nexus file you want to use
#ref2 <- attr(metadataRef,"names")

#builds a hashmap using the leaf node strings as keys and the character states as values
#H <- hashmap(ref2, metadataRef)
H <- hashmap(accessioncharacter, country)

# The asr_max_parsimony() function requires a numeric vector that lists the character states
#   of the leaf nodes in sequence as one of its parameter arguments. The following for loop
#   walks through the character vector $tip.label in the rootedTree list, starting at the 
#   index [1], and stores the value of $tip.label[i] in the character vector accession.
#   This character string is then passed into the find function of the hashmap and its
#   character state is returned. Thus when the loop is complete, it has populated 
#   the metadataStates numeric vector with the character states associated with the 
#   leaf nodes in the order that they appeal in $tip.label;
# Get character state for each node that isn't a leaf node (i.e. all the inner nodes)
#asr_max_parsimony accepts 3 parameters:
# - the list object returned by the read.tree() function
# - the character states of the leaf nodes listed in the $tip.label character vector found in
#     the list object
# - the number of possible character states of the trait
# 
# it returns a list object with the following components:
#
#   $ancestral_likelihoods - a numeric matrix object with nrows = the number of inner nodes 
#     in the phylogenetic tree, and ncolumns = to the number of possible character states
#     of the character trait being studied. The value at $ancestral_likelihoods[n,m] is 
#     the probability of interior node n being character state m
#   $success - a logical vector of length one that says whether the process was a success
#               or not
#/
#numCharStates <- length(nexusData$characterLabels[[characterIndex]]) ##### change to the number above
numCharStates <- length(characterlabels) ##### change to the number above
ancestralStates = asr_max_parsimony(rootedTree, country, numCharStates)

# Deletes all keys and values from the hashmap
H$clear()

# Rebuilds hashmap using sequential numbers 1 through the number of leaf nodes as the key/index 
#and using the integer values found in metadataStates as values. It essentially builds a hashmap 
#of the leaf nodes of the tree: their index and their value.
for(i in 1:length(country)) {
  H$insert(i, country[i])
}

# Loop through the inner nodes of the phylogenetic tree and assign the most likely character state
# to that tree node;
numLeaves <- length(country)
numInnerNodes <- rootedTree$Nnode
totalTreeNodes <- numLeaves + numInnerNodes
innerNodeIndices <- (numLeaves+1):totalTreeNodes
numCharacterStates <- length(ancestralStates$ancestral_likelihoods[1,])
counter <- c() #initializes counter vector
for (i in innerNodeIndices) # 474:945  # 473 leaf nodes + 472 inner nodes = 945 total;
{                                                                         
  counter <- ancestralStates$ancestral_likelihoods[i - numLeaves,] #numeric vector of character state 
  # probabilities for inner node of index i
  H$insert(i, match(max(counter), counter)) #enters a new key-value pair 
  #(inner node i -> most likely character state)
}

#after the previous for loop executes, we now have an ASR of the phylogenetic tree given in the beginning.
sourceList <- c()
targetList <- c()

#walk through each edge in the phylogenetic tree. if there's a state change between the two nodes, 
#add the character states to their respective vector 
#(diedge tail == sourceList, diedge head == targetList)

for(row in 1:nrow(rootedTree$edge)) 
{
  nextEdge <- rootedTree$edge[row,]
  edgeStates <- c(H$find(nextEdge[1]), H$find(nextEdge[2]))
  if (edgeStates[1] != edgeStates[2]) 
  {
    sourceList <- c(sourceList, edgeStates[1])
    targetList <- c(targetList, edgeStates[2])
  }
}

# This creates a table (in the form of a data frame) of the state changes that occur 
#in the phylogenetic tree;
dat <- data.frame(from = sourceList, to = targetList)
#counts the frequency of a specific state change occurring
edges <- plyr::count(dat)
names(edges)[names(edges) == "freq"] <- "value"

# Extract the selected metadata state label from the data
metastates <- characterlabels

##### NEW CODE BELOW TO CREATE TABLE FOR MAP FROM PARSIMONY DATA #####

dat2 = as_tibble(dat) #transforms transition state data to tibble
metastates2 = tibble::enframe(metastates) #transforms metastates in a tibble 

Edge_tib = left_join(dat2, metastates2, by = c("from" = "name")) %>% 
  left_join(metastates2, by = c("to" = "name"), suffix = c("_org", "_dst")) %>% 
  select(value_org, value_dst)
  
 colnames(Edge_tib) <-c("State_org","State_dst")
 
 Edge_filtered = Edge_tib

##### NEW CODE ABOVE TO CREATE TABLE FOR MAP FROM PARSIMONY DATA #####

nodes <- data.frame(id = 1:length(metastates), label = metastates) #, fixed = list(x = T, y = T))
igraph.Object <- graph.data.frame(edges,directed = T,vertices = nodes)

#ui <- readline(prompt = "Select a centrality metric. Enter 0 to simply calculate all metrics, 1 for indegree, 2 for outdegree, 3 betweenness, 4 closeness, 5 for degree or 6 for Source Hub Ratio: ")
if (ui == "0") #Calculates all the metrics and export on a text file delimited by comma.
{  
  indegree <- centr_degree(igraph.Object, mode = c("in")) #Calculates indegree = Destiny of shifts of metadata state for all nodes
  outdegree <- centr_degree(igraph.Object, mode = c("out")) #Calculates the Outdegree = Source of shifts of metadata state for all nodes
  all.degree <- centr_degree(igraph.Object, mode = c("all")) #Calculates the Degree = Hub, in and out of shifts of metadata state
  between.centrality <- betweenness(igraph.Object) #Calculates Betweenness Centrality
  closeness.centrality <- closeness(igraph.Object, mode = c("all")) #Calculates Closeness Centrality
  sourcehubratio <- outdegree$res/all.degree$res # This is the basic "Source Hub Ratio", still have to work on the normalizing formula
  
  #Create empty matrix and populate with the metrics
  outputFileMatrix <- matrix(ncol = 0, nrow = length(metastates)) %>%
    cbind(metastates,all.degree$res,indegree$res,outdegree$res,between.centrality,closeness.centrality,sourcehubratio)# %>%
  colnames(outputFileMatrix, do.NULL = FALSE)
  colnames(outputFileMatrix) <- c("Metastates","Degree Centrality","Indegree Centrality","Outdegree Centrality","Betweenness Centrality","Closeness Centrality", "Source Hub Ratio") 
  write.table(outputFileMatrix,file = "metrics.txt",sep = ",",fileEncoding = "UTF-8",col.names = TRUE,
              row.names = FALSE,quote = FALSE)
} else if (ui == "1") #indegree: enter the indegree as the value
{
  indegree <- centr_degree(igraph.Object, mode = c("in"))
  nodes <- data.frame(nodes, value = indegree$res, group = indegree$res)
  graph <- visNetwork(nodes = nodes, edges = edges, main = "Indegree Centrality",height = "768px", width = "1024")%>%
    visPhysics(solver = "repulsion")%>%
    visInteraction(navigationButtons = TRUE)%>%
    visOptions(selectedBy = "value", highlightNearest = TRUE, 
               nodesIdSelection = TRUE)%>%
    visEdges(arrows = list(to = list(enabled = T, scaleFactor = 0.75)))
}else if (ui == "2") #outdegree:
{
  outdegree <- centr_degree(igraph.Object, mode = c("out"))
  nodes <- data.frame(nodes, value = outdegree$res, group = outdegree$res)
  graph <- visNetwork(nodes = nodes, edges = edges, main = "Outdegree Centrality",height = "768px", width = "1024")%>%
    visPhysics(solver = "repulsion")%>%
    visInteraction(navigationButtons = TRUE)%>%
    visOptions(selectedBy = "value", highlightNearest = TRUE, 
               nodesIdSelection = TRUE)%>%
    visEdges(arrows = list(to = list(enabled = T, scaleFactor = 0.75)))
}else if (ui == "3") #betweenness centrality
{
  between.centrality <- betweenness(igraph.Object)
  nodes <- nodes <- data.frame(nodes, value = between.centrality, group = between.centrality)
  graph <- visNetwork(nodes = nodes, edges = edges, main = "Betweenness Centrality",height = "768px", width = "1024")%>%
    visPhysics(solver = "repulsion")%>%
    visInteraction(navigationButtons = TRUE)%>%
    visOptions(selectedBy = "value", highlightNearest = TRUE, 
               nodesIdSelection = TRUE)%>%
    visEdges(arrows = list(to = list(enabled = T, scaleFactor = 0.75)))
}else if(ui == "4") #closeness centrality
{
  closeness.centrality <- closeness(igraph.Object, mode = c("all"))
  nodes <- data.frame(nodes, value = closeness.centrality, group = closeness.centrality)
  graph <- visNetwork(nodes = nodes, edges = edges, main = "Closeness Centrality",height = "768px", width = "1024")%>%
    visPhysics(solver = "repulsion")%>%
    visInteraction(navigationButtons = TRUE)%>%
    visOptions(selectedBy = "value", highlightNearest = TRUE, 
               nodesIdSelection = TRUE)%>%
    visEdges(arrows = list(to = list(enabled = T, scaleFactor = 0.75)))
}else if (ui == "5") #all indegree/outdegree = degree centrality
{
  all.degree <- centr_degree(igraph.Object, mode = c("all"))
  nodes <- data.frame(nodes, value = all.degree$res, group = all.degree$res)
  graph <- visNetwork(nodes = nodes, edges = edges, main = "Degree Centrality",height = "768px", width = "1024")%>%
    visPhysics(solver = "repulsion")%>%
    visInteraction(navigationButtons = TRUE)%>%
    visOptions(selectedBy = "value", highlightNearest = TRUE, 
               nodesIdSelection = TRUE)%>%
    visEdges(arrows = list(to = list(enabled = T, scaleFactor = 0.75)))
}else if (ui == "6") #Source Hub Ratio
{
  outdegree <- centr_degree(igraph.Object, mode = c("out")) #Calculates the Outdegree = Source of shifts of metadata state for all nodes
  all.degree <- centr_degree(igraph.Object, mode = c("all")) #Calculates the Degree = Hub, in and out of shifts of metadata state
  sourcehubratio <- outdegree$res/all.degree$res # This is the basic "Source Hub Ratio", still have to work on the normalizing formula
  nodes <- data.frame(nodes, value = sourcehubratio, group = sourcehubratio)
  graph <- visNetwork(nodes = nodes, edges = edges, main = "Source Hub Ratio: Dead-end ~0 / Hub = .5 / Source = ~1",height = "768px", width = "1024")%>%
    visPhysics(solver = "repulsion")%>%
    visInteraction(navigationButtons = TRUE)%>%
    visOptions(selectedBy = "value", highlightNearest = TRUE, 
               nodesIdSelection = TRUE)%>%
    visEdges(arrows = list(to = list(enabled = T, scaleFactor = 0.75)))
  
}  

print(graph)

#### Plot transmission network in map using Leaflet ####

library(leaflet)
library(geosphere)

org_dst <- Edge_filtered # Edge_filtered = probability user filtered table 

latlong <- read.csv('chikv_geo.csv') #User have to input csv table with "Location","Latitude","Longitude" headers.

lat_long = as_tibble(latlong)

map_coord = left_join(org_dst, lat_long, by = c("State_org" = "Location")) %>% #Join lat_long and org_dst tables.
  left_join(lat_long, by = c("State_dst" = "Location"), suffix = c("_org", "_dst"))

mydf2 <- data.frame(InitialLoc = map_coord$State_org, #Rename and reorganize table to be input ready 
                    InitialLat = map_coord$Latitude_org, 
                    InitialLong = map_coord$Longitude_org,
                    NewLat = map_coord$Latitude_dst,
                    NewLong = map_coord$Longitude_dst,
                    EndLoc = map_coord$State_dst
)

p1 <- as.matrix(mydf2[,c(3,2)]) # it's important to list lng before lat here
p2 <- as.matrix(mydf2[,c(5,4)]) # and here

gcIntermediate(p1, p2,  #This enforces the pairs of Origin and Destination for the polylines (otherwise it will enforce all locations to be connected)
               breakAtDateLine = TRUE,
               n=100, 
               addStartEnd=TRUE,
               sp=TRUE) %>% 
  leaflet() %>% 
  addTiles() %>% 
  addCircleMarkers(lng = mydf2$InitialLong, lat = mydf2$InitialLat, popup= mydf2$InitialLoc)%>% #Origin is circle marker, transparency is related to number of transmissions to/from place. 
  addMarkers(lng = mydf2$NewLong, lat = mydf2$NewLat, popup= mydf2$EndLoc)%>% #Events of transmission to place are pinpointed, transparency is related to number of transmissions to/from place.
  addPolylines() #The darker the line the more traffic there is between the nodes.