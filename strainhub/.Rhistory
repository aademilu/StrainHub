listofcolumns <- as.list(data)
accessioncharacter <- as.character(listofcolumns$Accession) # Transforms accession from Factor into character
country <- as.numeric(listofcolumns$Country) # Transforms metadata state country from Factor into numeric
names(country) <- accessioncharacter # Assign accession ID reference to the variable country
characterlabels1 <- unique(listofcolumns$Country) #extract unique labels from Country column
characterlabels <- sort(as.character(characterlabels1)) #sort and create list of characters from previous vector - has to sort to match the order from the $country as when it becomes numeric is transformed to numbers in alphabetical order.
parsedInfo <- as.list(accessioncharacter = accessioncharacter,
country = country,
characterlabels = characterlabels)
View(parsedInfo)
parsedInfo <- list(accessioncharacter,
country,
characterlabels)
View(parsedInfo)
View(parsedInfo)
View(parsedInfo)
parsedInfo <- list(accessioncharacter = accessioncharacter,
country = country,
characterlabels = characterlabels)
View(parsedInfo)
View(parsedInfo)
source("strainhub_functions.R")
parsedInfo <- parse_metaandtree(treePath = rootedTree,
metadataPath = '../../../Downloads/ECSA_MASA_metadata.csv')
Edge_list <- parsimony_ancestral_reconstruction(accessioncharacter = parsedInfo$accessioncharacter,
country = parsedInfo$country,
characterlabels = parsedInfo$characterlabels,
rootedTree = rootedTree)
make_nj_map(filePath = '../../../Downloads/geodata.csv',
transmissionpath = Edge_list,
linecolor = "red",
circlecolor = "grey")
shiny::runApp()
rootedTree <- NJ_build_collapse(filePath = '../../../Downloads/ECSA_MASA_CHIKV.aln.fasta',
accession = "KX262996.1_Cameroon",
bootstrapValue = 80)
parsedInfo <- parse_metaandtree(treePath = rootedTree,
metadataPath = '../../../Downloads/ECSA_MASA_metadata.csv')
Edge_list <- parsimony_ancestral_reconstruction(accessioncharacter = parsedInfo$accessioncharacter,
country = parsedInfo$country,
characterlabels = parsedInfo$characterlabels,
rootedTree = rootedTree)
transmissionpath = Edge_list
filePath = '../../../Downloads/geodata.csv'
org_dst <- transmissionpath # transmissionpath = probability user filtered table for beast output, org dst table for parsimony ancestry reconstruction
latlong <- read.csv(filePath) #User have to input csv table with "Location","Latitude","Longitude" headers.
lat_long = as_tibble(latlong)
map_coord = left_join(org_dst, lat_long, by = c("State_org" = "Location")) %>% #Join lat_long and org_dst tables.
left_join(lat_long, by = c("State_dst" = "Location"), suffix = c("_org", "_dst"))
mydf <- data.frame(InitialLoc = map_coord$State_org, #Rename and reorganize table to be input ready
InitialLat = map_coord$Latitude_org,
InitialLong = map_coord$Longitude_org,
NewLat = map_coord$Latitude_dst,
NewLong = map_coord$Longitude_dst,
EndLoc = map_coord$State_dst
)
p1 <- as.matrix(mydf[,c(3,2)]) # it's important to list lng before lat here
p2 <- as.matrix(mydf[,c(5,4)]) # and here
map = gcIntermediate(p1, p2,  # This enforces the pairs of Origin and Destination for the polylines (otherwise it will enforce all locations to be connected)
breakAtDateLine = TRUE,
n=100,
addStartEnd=TRUE,
sp=TRUE) %>%
leaflet() %>%
addTiles() %>%   # addProviderTiles(providers$CartoDB.Positron) %>% #Alternative to regular tiles
addCircleMarkers(lng = mydf$InitialLong, lat = mydf$InitialLat, popup= mydf$InitialLoc, color = circlecolor)%>% #Origin is circle marker, transparency is related to number of transmissions to/from place.
#   addMarkers(lng = mydf$NewLong, lat = mydf$NewLat, popup= mydf$EndLoc, color = circlecolor)%>% #Events of transmission to place are pinpointed, transparency is related to number of transmissions to/from place.
addPolylines(color = linecolor) # The darker the line the more traffic there is between the nodes.
linecolor = "red"
circlecolor = "grey"
map = gcIntermediate(p1, p2,  # This enforces the pairs of Origin and Destination for the polylines (otherwise it will enforce all locations to be connected)
breakAtDateLine = TRUE,
n=100,
addStartEnd=TRUE,
sp=TRUE) %>%
leaflet() %>%
addTiles() %>%   # addProviderTiles(providers$CartoDB.Positron) %>% #Alternative to regular tiles
addCircleMarkers(lng = mydf$InitialLong, lat = mydf$InitialLat, popup= mydf$InitialLoc, color = circlecolor)%>% #Origin is circle marker, transparency is related to number of transmissions to/from place.
#   addMarkers(lng = mydf$NewLong, lat = mydf$NewLat, popup= mydf$EndLoc, color = circlecolor)%>% #Events of transmission to place are pinpointed, transparency is related to number of transmissions to/from place.
addPolylines(color = linecolor) # The darker the line the more traffic there is between the nodes.
map
shiny::runApp()
rsconnect::deployApp()
rsconnect::deployApp(appName = "StrainHub-Beta")
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("rhandsontable")
DF_na = data.frame(integer = c(NA, 2:10),
logical = c(NA, rep(TRUE, 9)),
character = c(NA, LETTERS[1:9]),
factor = c(NA, factor(letters[1:9])),
date = c(NA, seq(from = Sys.Date(), by = "days",
length.out = 9)),
stringsAsFactors = FALSE)
DF_na$factor_ch = as.character(DF_na$factor)
DF_na$date_ch = c(NA, as.character(seq(from = Sys.Date(), by = "days",
length.out = 9)))
rhandsontable(DF_na, width = 550, height = 300)
library(rhandsontable)
DF_na = data.frame(integer = c(NA, 2:10),
logical = c(NA, rep(TRUE, 9)),
character = c(NA, LETTERS[1:9]),
factor = c(NA, factor(letters[1:9])),
date = c(NA, seq(from = Sys.Date(), by = "days",
length.out = 9)),
stringsAsFactors = FALSE)
DF_na$factor_ch = as.character(DF_na$factor)
DF_na$date_ch = c(NA, as.character(seq(from = Sys.Date(), by = "days",
length.out = 9)))
rhandsontable(DF_na, width = 550, height = 300)
shiny::runGitHub("rhandsontable", "jrowen",
subdir = "inst/examples/rhandsontable_frontier")
runApp()
runApp()
runApp()
runApp()
View(makeTransNet)
View(makeTransNet)
View(NJ_build_collapse)
runApp()
library('Cairo')
?isolate
runApp()
?hot_to_r
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("DTedit")
devtools::install_github("jbryer/DTedit")
##### Create the shiny UI
ui <- fluidPage(
h3('DTedit Template'),
uiOutput('mycontacts')
)
##### Start the shiny app
shinyApp(ui = ui, server = server)
runApp('~/Desktop/DTedit_example.R')
runApp()
runApp()
runApp()
runApp(launch.browser = interactive())
runApp(launch.browser = interactive())
runApp(display.mode = "showcase")
runApp()
install.packages("shinysky")
hot.to.df <- function(b) {
# if theres is no data
if (length(b$data) == 0) {
return()
}
col.names <- unlist(b$colHeaders)
i = 0
f <- function(x) {
i <<- i + 1
#
null.pos <- sapply(x,is.null)
x[null.pos] <- NA
xx <- data.frame(x, stringsAsFactors = F)
colnames(xx) <- col.names
xx
}
bb <- plyr::ldply(b$data, f)
colnames(bb) <- col.names
bb
}
runApp()
runApp()
data.frame(NULL)
runApp()
shiny::runApp()
runApp()
runApp()
install.packges("shinyWidgets")
install.packages("shinyWidgets")
library(shinyWidgets)
runApp()
runApp()
runApp()
runApp()
shiny::runApp(system.file("shiny", package = "visNetwork"))
rsconnect::deployApp()
shiny::runApp()
source("install_packages.R")
runApp()
runApp()
runApp()
shiny::runApp()
treedata <- read.dna("../data/neighbor_joining/ECSA_MASA_CHIKV.aln.fasta", format="fasta")
# nexusTree2 <- read.tree(treeFileName) #imports file in newick format instead of nexus.
nexusTree2 <- treedata
# dataoriginal <- readr::read_csv(csvFileName, col_names = TRUE) #imports csv metadata file. It has to have header and ID column has to be the first and labeled "Accession" in order for script to work.
dataoriginal <- metadata
metadata <- readr::read_csv("../data/neighbor_joining/ECSA_MASA_metadata.csv", col_names = TRUE)
geodata <- readr::read_csv("../data/neighbor_joining/ECSA_MASA_geodata.csv", col_names = TRUE)
# nexusTree2 <- make_nj_tree(filePath = treeFileName, accession = rootSelection) # Don't Use
# nexusTree2 <- NJ_build_collapse(filePath = treeFileName, accession = rootSelection, bootstrapValue = 80)
nexusTree2 <- treedata
# dataoriginal <- readr::read_csv(csvFileName, col_names = TRUE) #imports csv metadata file. It has to have header and ID column has to be the first and labeled "Accession" in order for script to work.
dataoriginal <- metadata
sortingtable <- as.data.frame(nexusTree2$tip.label) # Takes Tip Label information from Newick tree and transforms into a table, add ID to it and basically reorders the CSV metadata frame to match the Newick file.
as.data.frame(nexusTree2)$tip.label
dna <- read.dna("../data/neighbor_joining/ECSA_MASA_CHIKV.aln.fasta", format="fasta")
# dna <- read.dna(filePath, format="fasta")
# Create data frame in phangorn format
aln_phyDat <- phyDat(dna, type="DNA", levels = NULL)
mt <- modelTest(aln_phyDat) # perform model test to build distance matrix
reducedmt <- mt[c(1,5),c(1,3)] # extracts rows 1 and 5 from modeltest, columns 1 and 3 (models accepted to build distance matrix)
maxmt <- reducedmt[which.max(reducedmt$logLik),] # selects model with highest likelihood
dna_dist <- dist.ml(aln_phyDat, model=maxmt$Model)  # builds distance matrix
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
root(nj(dist.dna(e, model=maxmt$Model)),accession))
accession <- "EF027139.1_India"
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
root(nj(dist.dna(e, model=maxmt$Model)),accession))
View(aln_NJ)
View(aln_NJ)
View(aln_phyDat)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
root(nj(dist.dna(e, model=maxmt$Model)), accession, resolve.root = TRUE))
dist.dna(e, model=maxmt$Model)
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist) %>% makeNodeLabel(method = "number")
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
root(nj(dist.dna(e, model=maxmt$Model)), accession))
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
root(nj(dist.dna(e, model=maxmt$Model)), accession))
View(aln_NJ)
View(aln_NJ)
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist) %>% makeNodeLabel(method = "number")
View(aln_NJ)
View(aln_NJ)
View(aln_NJ)
aln_NJ[["node.label"]]
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
root(nj(dist.dna(e, model=maxmt$Model)), accession))
data("woodmouse")
aln_NJ <- dist.dna(woodmouse) %>% nj()
View(aln_NJ)
View(aln_NJ)
dna <- data("woodmouse")
dna <- data("woodmouse")
aln_NJ <- dist.dna(dna, model=maxmt$Model) %>% nj()
View(maxmt)
f(woodmouse)
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist)
# dna <- read.dna(filePath, format="fasta")
# Create data frame in phangorn format
aln_phyDat <- phyDat(dna, type="DNA", levels = NULL)
mt <- modelTest(aln_phyDat) # perform model test to build distance matrix
reducedmt <- mt[c(1,5),c(1,3)] # extracts rows 1 and 5 from modeltest, columns 1 and 3 (models accepted to build distance matrix)
maxmt <- reducedmt[which.max(reducedmt$logLik),] # selects model with highest likelihood
dna_dist <- dist.ml(aln_phyDat, model=maxmt$Model)  # builds distance matrix
dna <- read.dna("../data/neighbor_joining/ECSA_MASA_CHIKV.aln.fasta", format="fasta")
# dna <- read.dna(filePath, format="fasta")
# Create data frame in phangorn format
aln_phyDat <- phyDat(dna, type="DNA", levels = NULL)
mt <- modelTest(aln_phyDat) # perform model test to build distance matrix
reducedmt <- mt[c(1,5),c(1,3)] # extracts rows 1 and 5 from modeltest, columns 1 and 3 (models accepted to build distance matrix)
maxmt <- reducedmt[which.max(reducedmt$logLik),] # selects model with highest likelihood
dna_dist <- dist.ml(aln_phyDat, model=maxmt$Model)  # builds distance matrix
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() %>% root(accession)
)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% makeNodeLabel(method = "number") %>% nj() %>% root(accession)
)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() %>% makeNodeLabel(method = "number")  %>% root(accession)
)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() %>% makeNodeLabel(method = "number")#  %>% root(accession)
)
root(myBoots, accession)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj()# %>% makeNodeLabel(method = "number")  %>% root(accession)
)
myBoots
# Collapse branches of poorly supported nodes into multifurcations with bootstrap values less than X%
temp <- aln_NJ # Dont want to change chikv_NJ file itself, assign to new variable for safekeeping
N <- length(aln_NJ$tip.label) # Get total number of taxa from tree
toCollapse <- match(which(myBoots<bootstrapValue)+N, temp$edge[,2]) # Match bootstrap value at node to 'destination' edge in second column, returns node number with bs <x%, to be collapsed
bootstrapValue <- 0.75
toCollapse <- match(which(myBoots<bootstrapValue)+N, temp$edge[,2]) # Match bootstrap value at node to 'destination' edge in second column, returns node number with bs <x%, to be collapsed
temp$edge.length[toCollapse] <- 0 # Assigns 0 to edge lengths of nodes with bs <x%, collapses
# di2multi collapse or resolve multichotomies in phylogenetic trees
collapsedTree <- di2multi(temp, tol=.00001) # For branch to be considered separate, must be at least this length
finaltree <- root(collapsedTree, out = accession, resolve.root = TRUE)
View(collapsedTree)
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() %>% makeNodeLabel(method = "number")  %>% root(accession)
)
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() %>% makeNodeLabel(method = "number") # %>% root(accession)
)
# Collapse branches of poorly supported nodes into multifurcations with bootstrap values less than X%
temp <- aln_NJ # Dont want to change chikv_NJ file itself, assign to new variable for safekeeping
N <- length(aln_NJ$tip.label) # Get total number of taxa from tree
toCollapse <- match(which(myBoots<bootstrapValue)+N, temp$edge[,2]) # Match bootstrap value at node to 'destination' edge in second column, returns node number with bs <x%, to be collapsed
temp$edge.length[toCollapse] <- 0 # Assigns 0 to edge lengths of nodes with bs <x%, collapses
# di2multi collapse or resolve multichotomies in phylogenetic trees
collapsedTree <- di2multi(temp, tol=.00001) # For branch to be considered separate, must be at least this length
finaltree <- root(collapsedTree, out = accession, resolve.root = TRUE)
finaltree <- root(collapsedTree, node = accession, resolve.root = TRUE)
View(collapsedTree)
# di2multi collapse or resolve multichotomies in phylogenetic trees
collapsedTree <- di2multi(temp, tol=.00001) %>% makeNodeLabel(method = "number") # For branch to be considered separate, must be at least this length
finaltree <- root(collapsedTree, node = accession, resolve.root = TRUE)
View(collapsedTree)
View(collapsedTree)
collapsedTree[["node.label"]]
collapsedTree <- di2multi(temp, tol=.00001)
View(collapsedTree)
View(collapsedTree)
plot(collapsedTree)
# di2multi collapse or resolve multichotomies in phylogenetic trees
collapsedTree <- di2multi(temp, tol=.00001) %>% makeNodeLabel(method = "number") # For branch to be considered separate, must be at least this length
plot(collapsedTree)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj()# %>% makeNodeLabel(method = "number") # %>% root(accession)
)
# Collapse branches of poorly supported nodes into multifurcations with bootstrap values less than X%
temp <- aln_NJ # Dont want to change chikv_NJ file itself, assign to new variable for safekeeping
N <- length(aln_NJ$tip.label) # Get total number of taxa from tree
toCollapse <- match(which(myBoots<bootstrapValue)+N, temp$edge[,2]) # Match bootstrap value at node to 'destination' edge in second column, returns node number with bs <x%, to be collapsed
temp$edge.length[toCollapse] <- 0 # Assigns 0 to edge lengths of nodes with bs <x%, collapses
# di2multi collapse or resolve multichotomies in phylogenetic trees
collapsedTree <- di2multi(temp, tol=.00001) %>% makeNodeLabel(method = "number") # For branch to be considered separate, must be at least this length
View(collapsedTree)
View(collapsedTree)
# di2multi collapse or resolve multichotomies in phylogenetic trees
collapsedTree <- di2multi(temp, tol=.00001) #%>% makeNodeLabel(method = "number") # For branch to be considered separate, must be at least this length
finaltree <- root(collapsedTree, node = accession, resolve.root = TRUE)
# di2multi collapse or resolve multichotomies in phylogenetic trees
collapsedTree <- di2multi(temp, tol=.00001) %>% makeNodeLabel(method = "number") # For branch to be considered separate, must be at least this length
finaltree <- root(collapsedTree, node = accession, resolve.root = TRUE)
finaltree <- root(collapsedTree, outgroup = accession, resolve.root = TRUE)
finaltree <- root(collapsedTree, node = "Node1", resolve.root = TRUE)
# rootedTree <<- ladderize(finaltree)
rootedTree <- ladderize(finaltree)
View(mt)
View(maxmt)
# Build NJ tree from distance matrix
#aln_NJ <- bionj(dna_dist)
aln_NJ <- NJ(dna_dist)
View(aln_NJ)
# dna <- read.dna(filePath, format="fasta")
# Create data frame in phangorn format
aln_phyDat <- phyDat(dna, type="DNA", levels = NULL)
mt <- modelTest(aln_phyDat) # perform model test to build distance matrix
reducedmt <- mt[c(1,5),c(1,3)] # extracts rows 1 and 5 from modeltest, columns 1 and 3 (models accepted to build distance matrix)
maxmt <- reducedmt[which.max(reducedmt$logLik),] # selects model with highest likelihood
dna_dist <- dist.ml(aln_phyDat, model=maxmt$Model)  # builds distance matrix
# Build NJ tree from distance matrix
#aln_NJ <- bionj(dna_dist)
aln_NJ <- NJ(dna_dist)
View(aln_NJ)
View(aln_NJ)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj()# %>% makeNodeLabel(method = "number") # %>% root(accession)
)
# Collapse branches of poorly supported nodes into multifurcations with bootstrap values less than X%
temp <- aln_NJ # Dont want to change chikv_NJ file itself, assign to new variable for safekeeping
N <- length(aln_NJ$tip.label) # Get total number of taxa from tree
toCollapse <- match(which(myBoots<bootstrapValue)+N, temp$edge[,2]) # Match bootstrap value at node to 'destination' edge in second column, returns node number with bs <x%, to be collapsed
temp$edge.length[toCollapse] <- 0 # Assigns 0 to edge lengths of nodes with bs <x%, collapses
# di2multi collapse or resolve multichotomies in phylogenetic trees
collapsedTree <- di2multi(temp, tol=.00001)# %>% makeNodeLabel(method = "number") # For branch to be considered separate, must be at least this length
finaltree <- root(collapsedTree, outgroup = accession, resolve.root = TRUE)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() # %>% root(accession)
)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() %>% root(accession)
)
View(aln_NJ)
View(aln_NJ)
plot(aln_NJ)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() %>% makeNodeLabel(method = "number") %>% root(accession)
)
View(aln_NJ)
View(aln_NJ)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model=maxmt$Model) %>% nj() %>% makeNodeLabel(method = "number") %>% root("Node1")
)
fit <- pml(aln_NJ, dna)
# dna <- read.dna(filePath, format="fasta")
# Create data frame in phangorn format
aln_phyDat <- phyDat(dna, type="DNA", levels = NULL)
fit <- pml(aln_NJ, aln_phyDat)
print(fit)
fit_model <- optim.pml(fit, model = maxmt$Model, rearrangement = "stochastic")
logLik(fitJC)
logLik(fit_model)
bs <- bootstrap.pml(fit_model,
bs=100,
optNni=TRUE,
multicore=TRUE,
control = pml.control(trace=0))
bs <- bootstrap.pml(fit_model,
bs=100,
optNni=TRUE,
#multicore=TRUE,
control = pml.control(trace=0))
plot(bs)
View(bs)
di2multi(bs, tol=.00001)
collapsedTree <- di2multi(bs, tol=.00001)
finaltree <- root(collapsedTree, outgroup = accession, resolve.root = TRUE)
# rootedTree <<- ladderize(finaltree)
rootedTree <- ladderize(finaltree)
View(finaltree)
bs <- bootstrap.phyDat(aln_phyDat,
bs=100)
bs <- bootstrap.phyDat(aln_phyDat,
bs=100, nj)
bs <- bootstrap.phyDat(aln_phyDat,
bs=100, nj())
bs <- bootstrap.phyDat(aln_phyDat,
bs=100, bionj)
data(Laurasiatherian)
orig.dna <- as.DNAbin(Laurasiatherian)
orig.dna[tips,]
est <- function(x){
dist.dna(x, model=maxmt$Model) %>% nj() %>% root(accession)
}
esttree <- est(dna)
est <- function(x){
aln_phyDat <- phyDat(x, type="DNA", levels = NULL)
mt <- modelTest(aln_phyDat) # perform model test to build distance matrix
reducedmt <- mt[c(1,5),c(1,3)] # extracts rows 1 and 5 from modeltest, columns 1 and 3 (models accepted to build distance matrix)
maxmt <- reducedmt[which.max(reducedmt$logLik),] # selects model with highest likelihood
dna_dist <- dist.ml(aln_phyDat, model=maxmt$Model)  # builds distance matrix
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist)
#aln_NJ <- NJ(dna_dist)
return(aln_NJ)
#dist.dna(x, model=maxmt$Model) %>% nj() %>% root(accession)
}
boot.res <- boot.phylo(esttree, dna, est, 50, trees=TRUE)
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model = maxmt$Model) %>%
nj() %>%
root(accession,
resolve.root = TRUE)
)
# Build NJ tree from distance matrix
#aln_NJ <- bionj(dna_dist)
aln_NJ <- NJ(dna_dist) %>% makeNodeLabel(method = "number")
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model = maxmt$Model) %>%
nj() %>%
root(accession,
resolve.root = TRUE)
)
View(aln_NJ)
# Build NJ tree from distance matrix
aln_NJ <- bionj(dna_dist) %>% makeNodeLabel(method = "number")
myBoots <- boot.phylo(aln_NJ, dna, function(e) # Run bootstrap
# root(nj(dist.dna(e, model=maxmt$Model)), accession))
dist.dna(e, model = maxmt$Model) %>%
nj() %>%
root(accession,
resolve.root = TRUE)
)
values_phyDat <- phyDat(dna, type="DNA", levels = NULL)
mt <- modelTest(values_phyDat)
reducedmt <- mt[c(1,5),c(1,3)] #extracts rows 1 and 5 from modeltest, columns 1 and 3
maxmt <- reducedmt[which.max(reducedmt$logLik),]
dna_dist <- dist.ml(values_phyDat, model=maxmt$Model)
values_NJ <- bionj(dna_dist)
plot(values_NJ, main="Neighbor Joining", cex=.6)
names(values_phyDat) #ID names for outgroup user selection down here:
tre2 <- root(values_NJ, out = accession, resolve.root = TRUE)
tre2 <- root(values_NJ, outgroup = accession, resolve.root = TRUE)
tre2 <- root(values_NJ, root = accession, resolve.root = TRUE)
tre2 <- root(values_NJ, node = accession, resolve.root = TRUE)
tre2 <- root(values_NJ, outgroup = accession, node = NULL, resolve.root = TRUE)
?root
tre2 <- root(values_NJ, outgroup = accession, node = 1, resolve.root = TRUE)
